# -*- mode: org; fill-column: 78; -*-
# Time-stamp: <2021-03-03 00:39:59 krylon>
#
#+TAGS: optimize(o) refactor(r) bug(b) feature(f) architecture(a)
#+TODO: TODO(t) IMPLEMENT(i) TEST(e) RESEARCH(r) | DONE(d)
#+TODO: MEDITATE(m) PLANNING(p) | FAILED(f) CANCELLED(c) SUSPENDED(s)
#+PRIORITIES: A G D

* Ticker
  Ticker is an RSS/Atom reader with a builtin archive and web interface.
  It supports tagging news items, and rating news items, with a bayesian
  classifier to automatically suggest ratings, as well as filtering news items
  based on suggested ratings.
** Clocktable
   #+BEGIN: clocktable :scope file :maxlevel 20
   #+CAPTION: Clock summary at [2021-03-03 Mi 00:39]
   | Headline                  | Time      |         |         |         |       |
   |---------------------------+-----------+---------+---------+---------+-------|
   | *Total time*              | *5d 2:51* |         |         |         |       |
   |---------------------------+-----------+---------+---------+---------+-------|
   | Ticker                    | 5d 2:51   |         |         |         |       |
   | \_  Main                  |           |    0:56 |         |         |       |
   | \_    Shutdown            |           |         |    0:56 |         |       |
   | \_  Components [11/13]    |           | 5d 1:55 |         |         |       |
   | \_    Feed [6/6]          |           |         | 1d 4:37 |         |       |
   | \_      Homepage          |           |         |         |    0:12 |       |
   | \_      Rating [3/3]      |           |         |         | 1d 1:09 |       |
   | \_        Web Frontend    |           |         |         |         | 12:09 |
   | \_        Classifier      |           |         |         |         | 12:23 |
   | \_    Database [1/1]      |           |         |   21:55 |         |       |
   | \_      Due Feeds         |           |         |         |    1:26 |       |
   | \_    Reader [0/0]        |           |         |   15:50 |         |       |
   | \_    Web interface [0/0] |           |         |   18:26 |         |       |
   | \_    Tags [2/3]          |           |         | 1d 7:35 |         |       |
   | \_      Database          |           |         |         |   10:59 |       |
   | \_        Hierarchy       |           |         |         |         |  8:58 |
   | \_      Web interface     |           |         |         |   18:46 |       |
   | \_    Search [2/2]        |           |         |    3:30 |         |       |
   | \_    Read Later          |           |         |    2:02 |         |       |
   #+END:

** Questions
** Main
   Main is, of course, the package / function that binds the whole thing
   together.
*** Shutdown
    :LOGBOOK:
    CLOCK: [2021-02-17 Mi 19:25]--[2021-02-17 Mi 20:21] =>  0:56
    :END:
** Components [11/13]
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
  :END:
*** Feed [6/6]
    :LOGBOOK:
    CLOCK: [2021-02-06 Sa 17:57]--[2021-02-06 Sa 18:47] =>  0:50
    CLOCK: [2021-02-05 Fr 20:57]--[2021-02-05 Fr 21:57] =>  1:00
    CLOCK: [2021-02-01 Mo 15:27]--[2021-02-01 Mo 16:29] =>  1:02
    CLOCK: [2021-02-01 Mo 12:46]--[2021-02-01 Mo 13:10] =>  0:24
    :END:
**** CANCELLED URL
     CLOSED: [2021-02-05 Fr 20:57]
     Is there an advantage to representing the URL as a *net.URL object?
**** DONE Fetching
     CLOSED: [2021-02-05 Fr 20:57]
**** DONE Homepage
     CLOSED: [2021-02-16 Di 13:44]
     :LOGBOOK:
     CLOCK: [2021-02-16 Di 13:32]--[2021-02-16 Di 13:44] =>  0:12
     :END:
**** Rating [3/3]
     :LOGBOOK:
     CLOCK: [2021-02-15 Mo 22:53]--[2021-02-15 Mo 23:30] =>  0:37
     :END:
***** DONE Database Queries
      CLOSED: [2021-02-16 Di 00:45]
***** DONE Web Frontend
      CLOSED: [2021-02-22 Mo 22:14]
      :LOGBOOK:
      CLOCK: [2021-02-22 Mo 21:04]--[2021-02-22 Mo 22:14] =>  1:10
      CLOCK: [2021-02-22 Mo 16:56]--[2021-02-22 Mo 18:52] =>  1:56
      CLOCK: [2021-02-19 Fr 13:06]--[2021-02-19 Fr 15:59] =>  2:53
      CLOCK: [2021-02-17 Mi 13:01]--[2021-02-17 Mi 14:06] =>  1:05
      CLOCK: [2021-02-17 Mi 00:05]--[2021-02-17 Mi 01:22] =>  1:17
      CLOCK: [2021-02-16 Di 17:28]--[2021-02-16 Di 21:16] =>  3:48
      :END:
***** DONE Classifier
      CLOSED: [2021-02-22 Mo 22:14]
      :LOGBOOK:
      CLOCK: [2021-02-22 Mo 15:54]--[2021-02-22 Mo 16:56] =>  1:02
      CLOCK: [2021-02-19 Fr 20:25]--[2021-02-19 Fr 20:59] =>  0:34
      CLOCK: [2021-02-18 Do 20:07]--[2021-02-18 Do 23:59] =>  3:52
      CLOCK: [2021-02-18 Do 17:28]--[2021-02-18 Do 18:02] =>  0:34
      CLOCK: [2021-02-18 Do 09:09]--[2021-02-18 Do 10:26] =>  1:17
      CLOCK: [2021-02-17 Mi 21:04]--[2021-02-18 Do 02:08] =>  5:04
      :END:
*** Database [1/1]
    :LOGBOOK:
    CLOCK: [2021-02-19 Fr 11:52]--[2021-02-19 Fr 13:06] =>  1:14
    CLOCK: [2021-02-15 Mo 23:30]--[2021-02-16 Di 00:44] =>  1:14
    CLOCK: [2021-02-05 Fr 13:15]--[2021-02-05 Fr 17:23] =>  4:08
    CLOCK: [2021-02-04 Do 18:55]--[2021-02-04 Do 20:30] =>  1:35
    CLOCK: [2021-02-04 Do 18:05]--[2021-02-04 Do 18:37] =>  0:32
    CLOCK: [2021-02-04 Do 12:47]--[2021-02-04 Do 13:52] =>  1:05
    CLOCK: [2021-02-04 Do 09:18]--[2021-02-04 Do 10:03] =>  0:45
    CLOCK: [2021-02-03 Mi 19:24]--[2021-02-03 Mi 23:04] =>  3:40
    CLOCK: [2021-02-02 Di 18:50]--[2021-02-02 Di 20:50] =>  2:00
    CLOCK: [2021-02-02 Di 07:53]--[2021-02-02 Di 07:59] =>  0:06
    CLOCK: [2021-02-01 Mo 16:30]--[2021-02-01 Mo 20:40] =>  4:10
    :END:
    Is there any reason /not/ to use good old SQLite?
    I don't think so.
**** DONE Due Feeds
     CLOSED: [2021-02-16 Di 00:45]
     :LOGBOOK:
     CLOCK: [2021-02-15 Mo 18:51]--[2021-02-15 Mo 20:17] =>  1:26
     :END:
     I want a method/query to fetch only feeds that are due for a refresh.
*** Reader [0/0]
    :LOGBOOK:
    CLOCK: [2021-02-17 Mi 19:12]--[2021-02-17 Mi 19:18] =>  0:06
    CLOCK: [2021-02-15 Mo 20:17]--[2021-02-15 Mo 20:52] =>  0:35
    CLOCK: [2021-02-15 Mo 18:40]--[2021-02-15 Mo 18:51] =>  0:11
    CLOCK: [2021-02-15 Mo 13:27]--[2021-02-15 Mo 15:30] =>  2:03
    CLOCK: [2021-02-14 So 23:05]--[2021-02-14 So 23:43] =>  0:38
    CLOCK: [2021-02-08 Mo 20:33]--[2021-02-08 Mo 21:16] =>  0:43
    CLOCK: [2021-02-08 Mo 19:25]--[2021-02-08 Mo 19:51] =>  0:26
    CLOCK: [2021-02-08 Mo 12:58]--[2021-02-08 Mo 15:36] =>  2:38
    CLOCK: [2021-02-07 So 17:45]--[2021-02-07 So 22:15] =>  4:30
    CLOCK: [2021-02-07 So 11:46]--[2021-02-07 So 15:46] =>  4:00
    :END:
*** Web interface [0/0]
    :LOGBOOK:
    CLOCK: [2021-02-18 Do 18:20]--[2021-02-18 Do 19:20] =>  1:00
    CLOCK: [2021-02-17 Mi 20:37]--[2021-02-17 Mi 21:03] =>  0:26
    CLOCK: [2021-02-16 Di 13:32]--[2021-02-16 Di 13:32] =>  0:00
    CLOCK: [2021-02-16 Di 12:15]--[2021-02-16 Di 12:55] =>  0:40
    CLOCK: [2021-02-16 Di 01:03]--[2021-02-16 Di 01:14] =>  0:11
    CLOCK: [2021-02-14 So 20:55]--[2021-02-14 So 22:51] =>  1:56
    CLOCK: [2021-02-13 Sa 15:08]--[2021-02-13 Sa 21:35] =>  6:27
    CLOCK: [2021-02-12 Fr 19:04]--[2021-02-12 Fr 23:56] =>  4:52
    CLOCK: [2021-02-12 Fr 17:21]--[2021-02-12 Fr 19:04] =>  1:43
    CLOCK: [2021-02-12 Fr 15:23]--[2021-02-12 Fr 16:34] =>  1:11
    :END:
*** Tags [2/3]
    :LOGBOOK:
    CLOCK: [2021-03-02 Di 18:54]--[2021-03-02 Di 20:44] =>  1:50
    :END:
    I would like to create tags and assign them to items.
    Furthermore, I would like to use the Bayesian classifier to suggest tags
    for Items and maybe assign them automatically eventually.
**** DONE Database
     CLOSED: [2021-03-03 Mi 00:39]
     :LOGBOOK:
     CLOCK: [2021-02-24 Mi 19:35]--[2021-02-24 Mi 21:36] =>  2:01
     :END:
***** SUSPENDED Hierarchy
      CLOSED: [2021-03-01 Mo 19:48]
      :LOGBOOK:
      CLOCK: [2021-03-01 Mo 19:19]--[2021-03-01 Mo 19:47] =>  0:28
      CLOCK: [2021-02-27 Sa 21:25]--[2021-02-28 So 00:48] =>  3:23
      CLOCK: [2021-02-27 Sa 16:51]--[2021-02-27 Sa 19:13] =>  2:22
      CLOCK: [2021-02-26 Fr 19:15]--[2021-02-26 Fr 22:00] =>  2:45
      :END:
      I need to figure out an SQL query to get the Tags in the right order,
      "right" meaning the order should reflect the hierarchy.
      ...
      That is surprisingly tricky, and given the fact it is not such a big
      problem, I postpone this.
**** TODO Web interface
     :LOGBOOK:
     CLOCK: [2021-03-02 Di 20:44]--[2021-03-03 Mi 00:38] =>  3:54
     CLOCK: [2021-02-26 Fr 18:49]--[2021-02-26 Fr 19:14] =>  0:25
     CLOCK: [2021-02-26 Fr 16:47]--[2021-02-26 Fr 18:07] =>  1:20
     CLOCK: [2021-02-25 Do 16:12]--[2021-02-26 Fr 00:13] =>  8:01
     CLOCK: [2021-02-25 Do 00:45]--[2021-02-25 Do 03:22] =>  2:37
     CLOCK: [2021-02-24 Mi 21:47]--[2021-02-25 Do 00:16] =>  2:29
     :END:     
*** Search [2/2]
    :LOGBOOK:
    CLOCK: [2021-02-23 Di 20:00]--[2021-02-23 Di 23:30] =>  3:30
    :END:
    I want to support full text search if possible. And it should be possible,
    SQLite has support for that. In fact, I think I already used it once, but
    I am somewhat fuzzy on the details.
**** DONE Database
     CLOSED: [2021-02-23 Di 23:30]
     I /might/ have to clean up the item data before feeding it to the FTS
     index, specifically remove all HTML tags.
     I will /try/ to use the content as-is, hoping, naively, that it will work
     well enough. But I will try to keep in mind this might be a problem.
     Now that I think of it, I might have to to do that for rating, too. :-|

     [2021-02-23 Di 21:17]
     I think I have got it ready, but I still need to test it, which in turn
     requires support in the web interface.
**** DONE Web interface
     CLOSED: [2021-02-23 Di 23:30]
*** TODO Read Later
    :LOGBOOK:
    CLOCK: [2021-03-02 Di 17:19]--[2021-03-02 Di 18:22] =>  1:03
    CLOCK: [2021-03-02 Di 14:45]--[2021-03-02 Di 15:05] =>  0:20
    CLOCK: [2021-03-01 Mo 20:01]--[2021-03-01 Mo 20:40] =>  0:39
    :END:
    It would be nice to be able to mark Items for later reading, so they do
    not get lost.
** Tedious tasks
